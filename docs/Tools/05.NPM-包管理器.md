---
title: NPM包管理器
date: '2021-10-21 10:34:30'
sidebar: 'auto'
categories:
 - 命令行
tags:
 - Cli
 - Tool
---

# NPM介绍

## NPM简介

**npm**（全称 Node Package Manager，即“node包管理器”）是[Node.js](https://zh.wikipedia.org/wiki/Node.js)默认的、用[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)编写的[软件包管理系统](https://zh.wikipedia.org/wiki/軟體套件管理系統)。npm会随着Node.js自动安装。npm模块仓库提供了一个名为“registry”的查询服务，用户可通过本地的npm命令下载并安装指定模块。此外用户也可以通过npm把自己设计的模块分发到registry上面

## NPM的由来

npm完全用[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)写成，最初由艾萨克·施吕特（Isaac Z. Schlueter）开发。艾萨克表示自己意识到“模块管理很糟糕”的问题，并看到了[PHP](https://zh.wikipedia.org/wiki/PHP)的[PEAR](https://zh.wikipedia.org/wiki/PEAR)与[Perl](https://zh.wikipedia.org/wiki/Perl)的[CPAN](https://zh.wikipedia.org/wiki/CPAN)等软件的缺点，于是编写了npm。

# NPM的命令行使用

基础命令的使用方法

```bash
$ npm <命令> [参数] 
```

## *登录/组织登录

```bash
# 组织登录
$ npm login # 登录当前用户
$ npm adduser # login的别名
$ npm login --scope=@组织名称

# 注销，删除链接和身份验证令牌
$ npm logout # 注销当前用户
$ npm logout --scope=@组织名称
```

指定注册地址

```bash
# 可选参数 注册地址
# --registry=https://registry.mycorp.com
$ npm login --registry=https://registry.npmjs.org
```

## *初始化/组织初始化

初始化生成一个包，可以理解为create...

```bash
# 初始化生成包
$ npm init
# 指定组织进行初始化 --yes的别名>表示跳过问卷
$ npm init --scope=@组织名称 -y
```

## *快速构建项目

该功能与Yarn Create相同,是一个速记命令，能一次性帮您完成两件事情

```bash
# 仅举例，无法使用
$ npm init pkg [<args>]
# 与下方命令一致
$ npm i -g create-pkg && create-pkg [<args>]
# 实际的命令转换其实是
$ npm exec create-pkg [<args>]
# 因为 npm exec|npm x|npx其实是相同的所以..
$ npx create-pkg [<args>]
```

可用例子

```bash
$ npm init vite vite-app
```

init命令转化为相应的`npm exec`操作如下：

- `npm init foo` -> `npm exec create-foo`
- `npm init @usr/foo` -> `npm exec @usr/create-foo`
- `npm init @usr` -> `npm exec @usr/create`

## 工作区初始化

> ~~什么是工作区?(暂无)~~

```bash
# 初始化一个工作区
$ npm init -w <dir>
# 通常来说都会以 packages/xxx作为工作区
$ npm init -w packages/pkg-name
```

> 快速构建工作区项目

```bash
# 先指定工作区， 后init快速初始化项目
$ npm init <workspace-option> pkg [<args>]
# 示例 init --workspace别名 workspace目录 viteCli 创建到当前目录
$ npm init -w packages/ws-vite vite .
```

## *添加/清除缓存

add/添加：将指定的包添加到本地缓存。此命令主要供 npm 内部使用，但它可以提供一种将数据显式添加到本地安装缓存的方法。

> 感知不强

```bash
$ npm cache add <pkg-name>
```

clean/清除：删除缓存文件夹中的所有数据。请注意，这通常是不必要的，因为 npm 的缓存是自我修复的并且可以抵抗数据损坏问题。

> 目测尝试只能全部删除,不能指定

```bash
$ npm cache clean
$ npm cache clear
$ npm cache rm
```

ls/列表：查看npm缓存列表

```bash
$ npm cache ls
```

verify/验证：验证缓存文件夹的内容，垃圾收集任何不需要的数据，并验证缓存索引和所有缓存数据的完整性

```bash
$ npm cache verify
```

## *快速打开包doc文档

快速到包的仓库，查看包文档或代码仓库。

```bash
$ npm docs <pkg-name>
$ npm home <pkg-name>
# 示例
$ npm docs antd
```

## *快速打开包issues

快速到包的仓库，查看issues，解决/提出问题

```bash
$ npm bugs <pkg-name>
```

## *修改/设置npm配置

npm 从命令行、环境变量、`npmrc`文件以及在某些情况下从`package.json`文件中获取其配置设置。主要是修改npm的源地址，npm环境变量等..

### 使用配置的优先级

> Project > user > global > builtin

### 配置文件npmrc

四个相关文件是：

- 每个项目的配置文件 [project]
- 每个用户的配置文件 [user]
- 全局配置文件 [global]
- npm 内置配置文件 [builtin]

### 查看所有层级配置

查看配置会显示所有的配

```bash
# bash use
$ npm <c|config> list
# 示例  -j是以 json输出
$ npm c list -j
# 查看全部配置
$ npm c list -l
```

### 查看使用中的一条值

能查看一条配置，当前作用域在使用的值，将其打印。

```bash
$ npm <c|config> get <config-name>
# 示例
$ npm c get registry
# <c|config>是可以省略的
$ npm get registry
```

### 设置/删除指定配置

> ``<c|config>``是可以不需要的

设置一个值

```bash
# 命令
$ npm <c|config> set <config-name> <config-value>
# 示例
$ npm c set userConfig user000 --location user
$ npm c set projectConfig project000 --location project
$ npm c set globalConfig global000 --location global
# 更方便的全局设置和删除 -g 是 --global 同等 --location global
$ npm c set globalConfig global000 -g
# <c|config>是可以省略的
$ npm set globalConfig global000 -g
```

​	删除一个值

> 参数将set修改为delete，且不能省略``<c|config>``,其他是一样的

```bash
# 命令
$ npm <c|config> set <config-name> <config-value>
# 示例
$ npm c delete userConfig user000 --location user
...
$ npm c delete globalConfig global000 -g
```

### 打开/编辑npmrc配置

> 打开文本直接编辑 npm配置

```bash
$ npm c edit
# 指定层级(作用域)
$ npm c edit --location project
```

## *指定已发布包某些版本弃用

此命令将更新包的 npm 注册表项，向所有尝试安装它的人提供弃用警告。

> 重复弃用可覆盖旧的弃用信息

```bash
# 模板
$ npm deprecate <pkg-name>[@ <version range>] <message>
# 弃用指定版本 
$ npm deprecate pkg@1.0.0 "因为弃用，所以弃用"
# 弃用指定范围版本
$ npm deprecate pack@"< 1.0.0" "1.0.0一下的版本都弃用了,望周知"
```

## *标签Tag管理

标签可用于提供别名而不是版本号。分流版本管理。

例如，一个项目可能会选择有发展的多个数据流，并使用不同的标签为每个数据流，如`stable`，`beta`，`dev`， `canary`。

拿Vue举个例子，Vue3已经在npm发布，但现在安装的Vue还是Vue2的，需要使用vue@next来安装Vue3的。next就是一个标签，Vue将Vue3的都发布在next这个标签内，如果不添加next会默认下载vue@latest

> 每个标签只有一个版本！版本库和标签是分离的。

> 如果发布时，不指定版本将会发布到latest，这时安装不@标签就会默认安装latest标签的版本

### 将某版本指定到某标签

> 需要发布者权限才能做此操作

```bash
# 模板
$ npm <dist-tag|dist-tags> add <pkg-name>@<version> <tag-name>
# 示例 将pkg@1.0.1 添加到旧版本tag
$ npm dist-tag add vuepress-plugin-typing@1.0.1 oldVersion
```

### 将某标签删除

>需要发布者权限才能做此操作

```bash
# 模板 
$ npm <dist-tag|dist-tags> rm <pkg-name> <tag-name>
# 示例 将pkg的 tag删除
$ npm dist-tag rm vuepress-plugin-typing oldVersion
```

### 发布到某个标签

> 需要发布者权限才能做此操作

> 如果发布时，不指定版本将会发布到latest，这时安装不@标签就会默认安装latest标签的版本

```bash
# 模板
$ npm pub --tag <tag-name>
# 示例
$ npm pub --tag beta
# 假如呢没有指定tag的情况，他默认将会是
$ npm pub --tag latest
```

### 查看某个包的标签

> 这个是不需要权限的...

```bash
# 模板
$ npm <dist-tag|dist-tags> ls <pkg-name> 
# 示例
$ npm dist-tag ls vue 
# 当然你也可以..使用info的 对象/json输出
$ npm info vue dist-tags 
```



## 删除node_modules中重复包

搜索本地包树并尝试通过将依赖关系进一步向上移动树来简化整体结构，在那里它们可以被多个依赖包更有效地共享。

> 通过[npm对比算法](https://docs.npmjs.com/cli/v7/commands/npm-dedupe)后，删除重复的包

```bash
$ npm dedupe
# 别名
$ npm ddp
```

## 使用锁快速安装

`npm ci` 在以下情况下会明显更快：

- 有一个`package-lock.json`或`npm-shrinkwrap.json`文件。
- 该`node_modules`文件夹丢失或为空。

```bash
$ npm ci
```

简而言之，使用`npm install`和之间的主要区别`npm ci`是：

- 该项目**必须**具有现有的`package-lock.json`或 `npm-shrinkwrap.json`.
- 如果包锁中的依赖项与 中的不匹配`package.json`， `npm ci`将退出并显示错误，而不是更新包锁。
- `npm ci` 一次只能安装整个项目：无法使用此命令添加单个依赖项。
- -如果 a`node_modules`已经存在，它将在`npm ci`开始安装之前自动删除。
- 它永远不会写入`package.json`或任何包锁：安装基本上是冻结的。

## 命令存放位置

```bash
# 打印全局存放位置
$ npm bin -g
# 打印当前项目存放位置
$ npm bin
```

## 指定包进行diff对比

| option                  | 说明                                       |
| ----------------------- | ------------------------------------------ |
| --diff=pkg              | 定义要在 中进行比较的参数,可多次设置       |
| --diff-name-only        | 使用时仅打印文件名                         |
| --diff-unified 3        | 要打印的上下文行数                         |
| --diff-ignore-all-space | 比较中的行时忽略空格                       |
| --diff-no-prefix        | 不要在`npm diff`输出中显示任何源或目标前缀 |
| --diff-src-prefix       | 要在`npm diff`输出中使用的源前缀           |
| --diff-dst-prefix       | 要在`npm diff`输出中使用的目标前缀         |
| --diff-text             | 将所有文件视为文本                         |

使用案例

```bash
# 模板
$npm diff --diff=<version-a> [...<paths>]
# 示例
$ npm diff --diff=uniq@0.0.2 --diff=uniq
$ npm diff --diff=uniq@0.0.2 --diff=uniq --diff-name-only
```

# NPX介绍

## NPX简介

npx原本是npm团队独立出来的一个npm包，用途是操作当前项目中的命令。后来npm将npx合并了，安装node时也会预置npx。在后续的版本中 npm也拥有 exec和 x等命令可直接代替npx

## *NPX的工作方式

1.先搜索当前的项目node_modules/.bin中是否存在需要执行的命令

2.再到比本地的全局搜索是否存在需要执行的命令

3.如果项目和本地的全局都没有能够执行的命令，会缓存一个文件夹，下载命令去执行，但执行完成后将删除缓存的文件夹

# NPX的命令行使用

基础命令的使用方法
